1. application.yml  프로티값 설정 ( 들여쓰기 잘 맞추는것이 yaml 문법에서 중요합니다.) 
spring: 
  jpa:
    hibernate:
      ddl-auto: create
    properties:
      hibernate:
        '[format_sql]': true
logging:
  level:
    '[org.hibernate.SQL]': debug       # sql 로그 확인

2. controller ----- service ----- repository 인터페이스(dao)  
              └ dto ┘   └ entity ┘   

dto : 요청과 응답에 필요한 구성으로 만듭니다.

3. Entity
영속성 역할을 하는 데이터베이스 테이블과 직접 매핑되는 클래스
=> 엔티티를 바탕으로 테이블 생성

4. Repository 인터페이스 정의 : 스프링이 JPA 구현체를 생성하고 bean 등록

extends JpaRepository<T, ID>   인터페이스를 상속 받는다.
                                ㄴ T는 테이블과 매핑되는 엔티티, ID는 PK 타입

------  상속 받은 메소드 (따로 정의하지 않고 사용함)  -----
save(entity)	엔티티(테이블 행) 저장 또는 수정 (INSERT/UPDATE)
saveAll(컬렉션)       여러 개의 엔티티 저장 또는 수정
findById(id)	ID로 단일 엔티티 조회
findAll()		모든 엔티티 조회
deleteById(id)	ID로 엔티티 삭제
deleteAll()		전체 엔티티 삭제
existsById(id)	해당 ID의 엔티티 존재 여부 확인
count()		전체 엔티티 개수 반환
findAll(Sort sort)	정렬 조건에 따라 전체 조회
findAll(Pageable p)	페이징 처리된 전체 조회

------------------------------------------
커스텀 메소드 정의 : 메소드 이름을 해석해서 쿼리를 자동 생성합니다.
List<T> findByName(String name); // name으로 조회
List<T> findByAgeGreaterThan(int age); // age가 특정 값보다 큰 사용자 조회


1) 네이티브 SQL 예시
@Query(value = "SELECT * FROM todo_test WHERE username = :username AND done = false", nativeQuery = true)
List<TodoEntity> findIncompleteTodosByUsernameNative(@Param("username") String username);

2) JPQL(엔티티와 그 필드를 대상으로 SQL) 예시
@Query("SELECT t FROM TodoEntity t WHERE t.username = :username AND t.checked = false")
List<TodoEntity> findIncompleteTodosByUsername(@Param("username") String username);


------------------  JPA 동작 ----------------------

[Repository] (Spring Data JPA)
   │   내부적으로 EntityManager 호출
   ▼
[EntityManager] (JPA 표준 API)
   │   영속성(JPA) 컨텍스트 관리
   ▼
[Hibernate] (JPA 구현체)
   │   JPQL → SQL 변환
   │   
   ▼
[JDBC API]
   │   SQL 실행
   ▼
[Database]
   │   결과 반환
   ▼
[Hibernate → EntityManager → Repository]

-------------------------------------------------------



5.  JPQL (Java Persistence Query Language)

JPA에서 제공하는 객체지향 쿼리 언어
SQL과 문법이 비슷하지만, 테이블이 아닌 엔티티 객체(Entity)를 대상으로 조회
DB 테이블에 직접 의존하지 않고, 엔티티 클래스와 필드를 기준으로 작성. 
리포지토리 메소드는 기본적으로  JPQL 을 사용함.

- 비교 
SQL은 테이블과 컬럼을 대상으로,
JPQL은 엔티티와 엔티티의 필드를 대상으로 한다.
JPA가 JPQL을 SQL로 변환해서 DB에 전달한다.

6. 영속성 컨텍스트 (Persistence Context)
JPA에서 엔티티를 관리하는 1차 캐시 영역
EntityManager가 관리하며, 엔티티 객체를 저장하고 조회하는 "가상의 DB 저장소" 같은 역할을 함.

-특징
1차 캐시 : 같은 트랜잭션 안에서 조회 시, DB에 재조회하지 않고 캐시에서 바로 가져옴.
(→ 성능 최적화)
동일성 보장 : 같은 값의 엔티티는 항상 같은 객체 인스턴스로 관리됨.(엔티티는 자동으로 불변객체)

